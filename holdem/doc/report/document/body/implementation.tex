
\newcommand{\xs}{$\spadesuit$}
\newcommand{\xh}{$\heartsuit$}
\newcommand{\xc}{$\clubsuit$}
\newcommand{\xd}{$\diamondsuit$}



\clearpage


\chapter{Poker Hand Evaluation}
\label{sec:HandEvaluation}

A hand evaluator is required in order to determine whether a set of cards is stronger than another.
This section presents a data structure for representation of a set of cards, as well as an efficient algorithm for computation of card strength for comparison.


\section{Poker Hands}
\label{sec:PokerHands}


From strongest to weakest the standard poker hands are:

\begin{itemize}
\singlespacing
\item Straight Flush: Five consecutive card values, all with the same suit
\item Four of a kind: Four matching cards
\item Full house: Three-of-a-kind and then a pair
\item Flush: Five cards with the same suit
\item Straight: Five consecutive card values, any suit
\item Three-of-a-kind: Three matching cards
\item Two-pair: Two different pairs
\item One pair: Two matching cards
\end{itemize}
Since all poker hands are five cards, the poker hands that don't use all five cards use the remaining cards to break ties.
The highest tiebreaking card wins.
If it is still a tie, the next highest tiebreaking card is compared next, until all five cards have been used.
If a tie cannot be broken with all five cards, neither hand wins.
In the case that no poker hand is made, all five cards are used to break ties --- this is commonly referred to as a 'high card' hand.
Holdem poker uses standard five-card poker hands, except players are always allowed to choose the best five cards out of seven available cards.


\section{Implementation}
\label{sec:HandEvaluationImplementation}

%In order to generate probability distributions to describe $Pr_\mathrm{*} \left( f_\mathrm{bet} | H \right)$ it is necessary to implement a ... evaluator.

%The ... evaluator uses Holdem-specific assumptions to improve efficiency.

\subsection{Data Structure}
\label{sec:DataStructure}

The core poker hand evaluator takes a seven cards as input, and produces a comparable card 'strength' object as output.
The strength of any seven cards can be represented with two values: the poker hand made and the tiebreaking cards.

By storing a set of cards as bitfields, the strength information can be computed efficiently.
A set of cards is stored as an array of four 16-bit integers (the 'cardset' array), and a single 32-bit integer (the 'valueset' integer).

Each of the four 16-bit 'cardset' integers represents an individual suit.
Each bit in each 'cardset' integer determines whether that card is contained in the set.
Storing aces as both bit 0 and bit 13 improves efficiency of the strength calculation stage.
\textbf{Table~\ref{tab:CardsetBitfield}} provides an example of the 'cardset' bitfield.

The 'valueset' integer determines how many times each card is contained in the set.
Every two bits are used to store a number between 0 and 3.
Although this representation is unable to store hands with four of a kind, it will be shown that the the valueset variable is not needed in four-of-a-kind situations.
\textbf{Table~\ref{tab:ValuesetInteger}} provides an example of the 'cardset' bitfield.

\begin{table}[htb]
\captionsetup{position=top}
\caption[Cardset Bitfield]{The 'cardset' bitfield for storing cards. Each integer in the cardset array represents a separate suit.
In this example, index 0, 1, 2, and 3 represent space, hearts, clubs, and diamonds, respectively.
The set of cards represented by (3080, 8, 8193, 14) is Q\xs{} J\xs{} 3\xs{} 4\xh{} A\xc{} 4\xd{} 3\xd{} 2\xd{}.
Bits 14 and higher are unused.}
\begin{small}
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|r|}
\hline
Bit                 &  \ordinalnum{13} & \ordinalnum{12} & \ordinalnum{11} & \ordinalnum{10} & \ordinalnum{9} & \ordinalnum{8} & \ordinalnum{7} & \ordinalnum{6} & \ordinalnum{5} & \ordinalnum{4} & \ordinalnum{3} & \ordinalnum{2} & \ordinalnum{1} & \ordinalnum{0} &                        \\ \hline
Card                &                A &               K & Q               & J               & 10             &              9 &              8 & 7              &              6 &  5             &              4 &              3 & 2              & A              &                         \\ \hline
                    &                  &                 &                 &                 &   &   &   &   &   &   &   &   &                         &                     & Integer                       \\ \hline
\texttt{cardset[0]} &     0            &        0        & 1               &  1              &  0 & 0  &  0 &  0 &  0 &0   &  1  & 0    & 0    & 0     & 3080   \\
\texttt{cardset[1]} &     0            &    0            & 0               & 0               &  0 & 0  & 0  &  0 &  0 & 0  &  1  & 0    & 0    &  0    & 8   \\
\texttt{cardset[2]} &     1            &    0            &  0              &  0              &  0 & 0  &  0 & 0  &  0 &  0 & 0   &  0   &  0   &  1    & 8193           \\
\texttt{cardset[3]} &     0            &     0           &  0              &  0              &   0 &   0&  0 &  0 &   0& 0  & 1  &  1   &  1   & 0     & 14      \\
\hline
\end{tabular}
\label{tab:CardsetBitfield}
\end{center}
\end{small}
\end{table}

\begin{table}[htb]
\captionsetup{position=top}
\caption[Valueset field]{The 'valueset' integer corresponding to the cardset bitfield example of \textbf{Table~\ref{tab:CardsetBitfield}}.
Every pair of bits denotes how many occurances of that value exist in the set of cards.
In this case, there is one A, one Q, one J, three fours, a three, and a two.
The actual integer value is 72351957.}
\begin{small}
\begin{center}
\begin{tabular}{|r|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
Bits    &  27-26 & 25-24 & 23-22 & 21-20 & 19-18 & 17-16 & 15-14 & 13-12 & 11-10 & 9-8 & 7-6 & 5-4 & 3-2 & 1-0                       \\ \hline
Card    &    A    &     K & Q     & J     & 10    &     9 &     8 & 7     &     6 &  5  &   4 &   3 & 2   & A                          \\ \hline
Value  &    1    &0      & 1     &  1    &  0    & 0     &  0    &  0    &  0    &0    &  3  & 1   & 1   & 1     \\
\hline
\end{tabular}
\label{tab:ValuesetInteger}
\end{center}
\end{small}
\end{table}

The 'cardset' bitfield is used to efficiently determine whether a certain card is contained in the hand.
The 'valueset' bitfield can efficienctly determine how many cards of a certain value are contained in the hand.

For the purposes of strength calculation, 

\subsection{Strength Calculation}
\label{sec:StrengthCalculation}

The first step of the strength calculation involves detecting what poker hand has been made.
Detecting straights and flushes take advantage of the 'cardset' representation.
Detecting flushes and matches (pair, two-pairs, full house, etc.) is done incrementally, as each card is added to the set.

Straight flushes can be detected by shifting and ANDing each of the 'cardset' bitfields.
Straights can be detected by looking for straight flushes within a combined bitfield that is the bitwise OR of the four 'cardset' bitfields.
To detect flushes, any time a card is added to the set, a corresponding counter is incremented for that suit.
Any counter exceeding five indicates that the poker hand contains at least a flush.
%by counting the number of 1s in each cardset bitfield (excluding the Ace at bit 0 so that it is not double-counted).
%Card matches (pairs, two-pairs, three-of-a-kind, full house, four-of-a-kind) are also detected incrementally.
A list of the top two pairs is always stored, and the list is updated whenever another pair occurs.
If a card with a value that has already paired is added to a set of cards, the hand is promoted to a three-of-a-kind, or to a full house if another pair already exists.
The same applies to four-of-a-kind.

For the purposes of implementation it is safe to assume that no more cards will be added after seven cards have been added.

\subsection{Tiebreaking}
\label{sec:Tiebreaking}
Two hands that have the same strength (eg. two-pair vs. another two-pair) require tiebreaking 

\subsection{Iteration}
\label{sec:Iteration}


\clearpage
